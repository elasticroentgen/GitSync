{
  "url": "https://api.github.com/repos/ethereum/solidity/issues/13055",
  "repository_url": "https://api.github.com/repos/ethereum/solidity",
  "labels_url": "https://api.github.com/repos/ethereum/solidity/issues/13055/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/solidity/issues/13055/comments",
  "events_url": "https://api.github.com/repos/ethereum/solidity/issues/13055/events",
  "html_url": "https://github.com/ethereum/solidity/issues/13055",
  "id": 1246464291,
  "node_id": "I_kwDOAm_5kc5KS4kj",
  "number": 13055,
  "title": "Reference types design",
  "user": {
    "login": "CodeSandwich",
    "id": 26183680,
    "node_id": "MDQ6VXNlcjI2MTgzNjgw",
    "avatar_url": "https://avatars.githubusercontent.com/u/26183680?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/CodeSandwich",
    "html_url": "https://github.com/CodeSandwich",
    "followers_url": "https://api.github.com/users/CodeSandwich/followers",
    "following_url": "https://api.github.com/users/CodeSandwich/following{/other_user}",
    "gists_url": "https://api.github.com/users/CodeSandwich/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/CodeSandwich/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/CodeSandwich/subscriptions",
    "organizations_url": "https://api.github.com/users/CodeSandwich/orgs",
    "repos_url": "https://api.github.com/users/CodeSandwich/repos",
    "events_url": "https://api.github.com/users/CodeSandwich/events{/privacy}",
    "received_events_url": "https://api.github.com/users/CodeSandwich/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 0,
  "created_at": "2022-05-24T12:20:15Z",
  "updated_at": "2022-05-24T12:20:15Z",
  "closed_at": null,
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "## Abstract\r\n\r\nSolidity references have limited capabilities and are sometimes tricky to use. I believe that their design needs to be improved to make the language more powerful, easier to learn and harder to write bugs in.\r\n\r\nI'm raising this issue because it seems widely recognized when talking to Solidity users, but I couldn't find any issue or even a discussion addressing it. Here are a few pain points I've been personally wrestling with, but I'm sure that there are many more cases like this.\r\n\r\n### No primitive types memory references\r\n\r\nIt's impossible to create a reference to memory containing a primitive type:\r\n\r\n```solidity\r\nfunction foo() public pure {\r\n    bool memory a; // Illegal\r\n}\r\n```\r\n\r\nThe primitive must be wrapped in a structure or an array to do that.\r\n\r\n### No storage of references\r\n\r\nIt's impossible to store any reference anywhere except a local variable:\r\n\r\n```solidity\r\nMyStruct public a;\r\nMyStruct storage public b; // Illegal\r\n\r\nfunction foo(Mystruct calldata c) public {\r\n    b = a; // Illegal\r\n    MyStruct memory storage d = a; // Illegal\r\n    MyStruct memory calldata e = c; // Illegal\r\n}\r\n```\r\n\r\n### No reference comparisons\r\n\r\nIt's impossible to compare two references and check if they point at the same location:\r\n\r\n```solidity\r\nfunction foo(MyStruct memory a, MyStruct memory b) public pure {\r\n    require(a != b); // Illegal\r\n}\r\n```\r\n\r\nIt's also not possible to easily compare the referenced values.\r\n\r\n### No copying between memory locations\r\n\r\nIt's impossible to directly copy data between two memory locations:\r\n\r\n```solidity\r\nfunction foo(MyStruct memory a, MyStruct memory b) public view {\r\n    a = b; // Does not copy\r\n    a = MyStruct(b.x, b.y, b.z); // Workaround\r\n}\r\n```\r\n\r\n### Confusing assignment rules\r\n\r\nThe assignments are tricky, depending on exact types they may create copies of data or references. The reviewer of code must know the context of an assignment and remember the rules to understand what's happening and spot potential bugs or inefficiencies:\r\n\r\n```solidity\r\nfunction foo() public {\r\n    ...\r\n    a = b; // Does it copy or create a reference?\r\n    ...\r\n}\r\n```\r\n\r\n### Wrap-up\r\n\r\nMany of these pain points compose into larger problems when coding, e.g. lack of in-memory references and lack of primitives references. Some problems, like lack of memory array slices, may or may not be solvable with a clever references design, but I've intentionally omitted them not to derail any potential conversation into the gray area. All limitations I've described here are often worked around using inline assembly, which is inelegant, dangerous and produces fragile code.\r\n\r\n## Motivation, Specification, Backwards Compatibility\r\n\r\nIn this sections I'm supposed to propose a solution, but unfortunately I can't. I don't have the knowledge or experience around programming languages design and I'm not even familiar with Solidity source code, as of now all I can do is flag the problem.\r\n\r\nI'm afraid that another evolutionary tweak to the references design can't solve these issues, probably a deeper reconsideration and a holistic approach are needed. Maybe existing languages could be used as an established template, especially lower-level ones?\r\n\r\nBackwards compatibility is a big problem with deep changes like this. Maybe two designs could coexist, e.g. a project could use the new one but its dependencies could still be written using the old one?",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/13055/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/solidity/issues/13055/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[

]
