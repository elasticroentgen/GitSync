{
  "url": "https://api.github.com/repos/ethereum/solidity/issues/12533",
  "repository_url": "https://api.github.com/repos/ethereum/solidity",
  "labels_url": "https://api.github.com/repos/ethereum/solidity/issues/12533/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/solidity/issues/12533/comments",
  "events_url": "https://api.github.com/repos/ethereum/solidity/issues/12533/events",
  "html_url": "https://github.com/ethereum/solidity/issues/12533",
  "id": 1102893611,
  "node_id": "I_kwDOAm_5kc5BvNIr",
  "number": 12533,
  "title": "IR-based compilation w/o optimization uses way too many stack slots, easily hits stack too deep errors",
  "user": {
    "login": "haltman-at",
    "id": 35589221,
    "node_id": "MDQ6VXNlcjM1NTg5MjIx",
    "avatar_url": "https://avatars.githubusercontent.com/u/35589221?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/haltman-at",
    "html_url": "https://github.com/haltman-at",
    "followers_url": "https://api.github.com/users/haltman-at/followers",
    "following_url": "https://api.github.com/users/haltman-at/following{/other_user}",
    "gists_url": "https://api.github.com/users/haltman-at/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/haltman-at/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/haltman-at/subscriptions",
    "organizations_url": "https://api.github.com/users/haltman-at/orgs",
    "repos_url": "https://api.github.com/users/haltman-at/repos",
    "events_url": "https://api.github.com/users/haltman-at/events{/privacy}",
    "received_events_url": "https://api.github.com/users/haltman-at/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 249074437,
      "node_id": "MDU6TGFiZWwyNDkwNzQ0Mzc=",
      "url": "https://api.github.com/repos/ethereum/solidity/labels/enhancement",
      "name": "enhancement",
      "color": "84b6eb",
      "default": true,
      "description": null
    },
    {
      "id": 1282209978,
      "node_id": "MDU6TGFiZWwxMjgyMjA5OTc4",
      "url": "https://api.github.com/repos/ethereum/solidity/labels/optimizer",
      "name": "optimizer",
      "color": "d4c5f9",
      "default": false,
      "description": ""
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 2,
  "created_at": "2022-01-14T03:52:31Z",
  "updated_at": "2022-01-31T17:20:29Z",
  "closed_at": null,
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "## Description\r\n\r\nCompiling Solidity with `viaIR: true` but the optimizer turned off results in bytecode that uses an enormous number of stack slots and runs into \"stack too deep\" errors with high frequency, in situations where the Solidity compiler would normally have plenty of stack space left (see repro example below).\r\n\r\nBasically what's going on here seems to be that, when`viaIR` is set to true, the Solidity compiler generates code that doesn't discard intermediate results after it's done with them.  Ordinarily, Solidity divides each stackframe into a lower area for local variables, and a higher area for working state, and the latter only sticks around as necessary.  But with `viaIR: true`, it's all mixed together, and none of it is discarded promptly.\r\n\r\nFor instance, with the code below (but with the lines about `w` removed so that it actually compiles with `viaIR: true`), the line `uint x = 1`, which would normally result in a single 1 being placed on the stack, in the slot representing `x`, instead results in *two* 1s being placed on the stack; presumably, one for the literal and one for `x`, and the one for the literal then doesn't go away.  All sorts of other intermediate results just remain on the stack as well, even after there's no more need for them, such as the value of `x+y`, the signature of `Num` (multiple times), and the literal `88`.\r\n\r\nAnd, of course, one result of using so many stack slots and not discarding anything is that it's really to hit stack too deep errors, in situations where the Solidity compiler wouldn't normally be anywhere near such an error.\r\n\r\nThanks!\r\n\r\n## Environment\r\n\r\n- Compiler version: 0.8.11\r\n- Target EVM version (as per compiler settings): default\r\n- Framework/IDE (e.g. Truffle or Remix): Truffle\r\n\r\n## Steps to Reproduce\r\n\r\nHere's an exampe of a contract that won't compile with `viaIR` on due to stack-too-deep errors:\r\n\r\n```solidity\r\n//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract StackTest {\r\n\r\n  event Num(uint);\r\n\r\n  function doStuff() public {\r\n    uint x = 1;\r\n    uint y = 2;\r\n    uint z = 3;\r\n    uint w = 4;\r\n    emit Num(w);\r\n    emit Num(z);\r\n    emit Num(x);\r\n    emit Num(y);\r\n    emit Num(x + y);\r\n    emit Num(88);\r\n  }\r\n}\r\n```\r\n\r\nCompiling with `viaIR: true` yields the error message:\r\n\r\n```\r\nYulException: Variable var_x_42 is 3 slot(s) too deep inside the stack.\r\n```\r\n\r\nMeanwhile, with `viaIR: false`, this compiles just fine, because the compiler isn't wasting huge numbers of stack slots.\r\n\r\nI'll skip including repro steps for the other stuff, but if you just take the above contract and delete the lines mentioning `w`, you'll get the contract I observed them with.",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/12533/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/solidity/issues/12533/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1013073350",
    "html_url": "https://github.com/ethereum/solidity/issues/12533#issuecomment-1013073350",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/12533",
    "id": 1013073350,
    "node_id": "IC_kwDOAm_5kc48YkXG",
    "user": {
      "login": "ekpyron",
      "id": 1347491,
      "node_id": "MDQ6VXNlcjEzNDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1347491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ekpyron",
      "html_url": "https://github.com/ekpyron",
      "followers_url": "https://api.github.com/users/ekpyron/followers",
      "following_url": "https://api.github.com/users/ekpyron/following{/other_user}",
      "gists_url": "https://api.github.com/users/ekpyron/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ekpyron/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ekpyron/subscriptions",
      "organizations_url": "https://api.github.com/users/ekpyron/orgs",
      "repos_url": "https://api.github.com/users/ekpyron/repos",
      "events_url": "https://api.github.com/users/ekpyron/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ekpyron/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-01-14T12:22:46Z",
    "updated_at": "2022-01-14T12:25:49Z",
    "author_association": "MEMBER",
    "body": "The IR/Yul code generation from solidity is intentionally \"safe and stupid\", i.e. it indeed produces a local Yul-variable for each intermediate expression (you quickly see it in compiling the contract with ``solc --ir``).\r\nThe unoptimized code transform from Yul code to EVM code is similarly \"safe and stupid\" and, as you say, doesn't do any cleanup after the last use of a Yul variable.\r\n\r\nIn general, the ``viaIR`` pipeline is not intended to be run without at least some degree of optimization.\r\n\r\nSo this is not exactly unexpected or unintentional, but I agree that it's a bad situation in which the default compiler runs fail even on simple contracts - we should probably enable a minimal set of optimizations by default - however, that's something we'd want to coordinate with you, s.t. we can retain debugging.\r\n\r\nThe currently minimal amount of optimization already makes the contract compilable:\r\n```\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"details\": {\r\n        \"peephole\": false,\r\n        \"inliner\": false,\r\n        \"jumpdestRemover\": false,\r\n        \"orderLiterals\": false,\r\n        \"deduplicate\": false,\r\n        \"cse\": false,\r\n        \"constantOptimizer\": false,\r\n        \"yul\": true,\r\n        \"yulDetails\": {\r\n          \"stackAllocation\": false,\r\n          \"optimizerSteps\": \"\"\r\n        }\r\n      }\r\n    }\r\n```\r\n(although right now this will run *some* hard-coded Yul optimizer steps, we'll allow to disable those in the near future as well https://github.com/ethereum/solidity/issues/9627)\r\n\r\nIn particular, the ``yulDetails`` option ``stackAllocation`` will have significant effects on the stack-effectiveness of the yul-to-evm transformation.\r\n\r\nLong story short:\r\n- At the moment it's expected that fully unoptimized compilation via IR fails quickly due to stack-too-deep.\r\n- Eventually we may enable some sane minimal optimizations by default, s.t. this stack-too-deep doesn't happen by default all the time.\r\n- We have to figure out how we can help e.g. the Truffle debugger to be able to deal with the compilation result with and without optimization.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1013073350/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1026019388",
    "html_url": "https://github.com/ethereum/solidity/issues/12533#issuecomment-1026019388",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/12533",
    "id": 1026019388,
    "node_id": "IC_kwDOAm_5kc49J9A8",
    "user": {
      "login": "chriseth",
      "id": 9073706,
      "node_id": "MDQ6VXNlcjkwNzM3MDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9073706?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chriseth",
      "html_url": "https://github.com/chriseth",
      "followers_url": "https://api.github.com/users/chriseth/followers",
      "following_url": "https://api.github.com/users/chriseth/following{/other_user}",
      "gists_url": "https://api.github.com/users/chriseth/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chriseth/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chriseth/subscriptions",
      "organizations_url": "https://api.github.com/users/chriseth/orgs",
      "repos_url": "https://api.github.com/users/chriseth/repos",
      "events_url": "https://api.github.com/users/chriseth/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chriseth/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-01-31T17:20:28Z",
    "updated_at": "2022-01-31T17:20:28Z",
    "author_association": "MEMBER",
    "body": "Would it be an option to disable any code modifications but enable the optimized evm code transforrm?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1026019388/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
